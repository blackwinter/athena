#! /usr/bin/ruby

#--
###############################################################################
#                                                                             #
# athena -- Convert database files to various formats                         #
#                                                                             #
# Copyright (C) 2007-2010 University of Cologne,                              #
#                         Albertus-Magnus-Platz,                              #
#                         50923 Cologne, Germany                              #
#                                                                             #
# Authors:                                                                    #
#     Jens Wille <jens.wille@uni-koeln.de>                                    #
#                                                                             #
# athena is free software; you can redistribute it and/or modify it under the #
# terms of the GNU General Public License as published by the Free Software   #
# Foundation; either version 3 of the License, or (at your option) any later  #
# version.                                                                    #
#                                                                             #
# athena is distributed in the hope that it will be useful, but WITHOUT ANY   #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   #
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       #
# details.                                                                    #
#                                                                             #
# You should have received a copy of the GNU General Public License along     #
# with athena. If not, see <http://www.gnu.org/licenses/>.                    #
#                                                                             #
###############################################################################
#++

require 'optparse'
require 'yaml'

$: << File.join(File.dirname(__FILE__), '..', 'lib')

require 'athena'

USAGE = "Usage: #{$0} [-h|--help] [options]"
abort USAGE if ARGV.empty?

# Global variable to handle verbosity
$Verbose = {}

options = {
  :config => 'config.yaml',
  :input  => STDIN,
  :output => STDOUT,
  :target => nil
}

OptionParser.new { |opts|
  opts.banner = USAGE

  opts.separator ''
  opts.separator 'Options:'

  opts.on('-c', '--config YAML', "Config file [Default: #{options[:config]}#{' (currently not present)' unless File.readable?(options[:config])}]") { |f|
    abort "Can't find config file: #{f}." unless File.readable?(f)

    options[:config] = f
  }

  opts.separator ''

  opts.on('-i', '--input FILE',  "Input file [Default: STDIN]") { |f|
    abort "Can't find input file: #{f}." unless File.readable?(f)

    options[:input] = File.directory?(f) ? Dir.open(f) : File.open(f, 'r')

    p = File.basename(f).split('.')
    options[:spec_fallback]   = p.last.downcase
    options[:target_fallback] = p.size > 1 ? p[0..-2].join('.') : p.first
  }

  opts.on('-s', '--spec SPEC', "Input format (spec) [Default: file extension of <input-file>]") { |s|
    options[:spec] = s.downcase
  }

  opts.on('-L', '--list-specs', "List available input formats (specs) and exit") {
    puts 'Available input formats (specs):'

    Athena.input_formats.each { |f, k|
      puts "  - #{f}#{" (= #{k})" if f != k.to_s}"
    }

    exit 0
  }

  opts.separator ''

  opts.on('-o', '--output FILE',  "Output file [Default: STDOUT]") { |f|
    options[:output] = File.open(f, 'w')

    options[:format_fallback] = f.split('.').last.downcase
  }

  opts.on('-f', '--format FORMAT', "Output format [Default: file extension of <output-file>]") { |f|
    options[:format] = f.downcase
  }

  opts.on('-l', '--list-formats', "List available output formats and exit") {
    puts 'Available output formats:'

    Athena.output_formats.each { |f, k|
      puts "  - #{f}#{" (= #{k})" if f != k.to_s}"
    }

    exit 0
  }

  opts.separator ''

  opts.on('-t', '--target ID', "Target whose config to use [Default: <input-file> minus file extension,", "plus '.<spec>', plus ':<format>' (reversely in turn)]") { |t|
    options[:target] = t
  }

  opts.separator ''
  opts.separator 'Generic options:'

  opts.on('-v', '--verbose [WHAT]', "Be verbose about what's being done. Optional argument is a comma-separated", "list of what should be output, or 'all' [Default: 'all']") { |what|
    if what.nil? || what == 'all'
      $Verbose.default = true
    else
      what.split(',').each { |w|
        $Verbose[w.to_sym] = true
      }
    end
  }

  opts.on('-h', '--help', 'Print this help message and exit') {
    abort opts.to_s
  }

  opts.on('--version', 'Print program version and exit') {
    abort "#{File.basename($0)} v#{Athena::VERSION}"
  }
}.parse!

spec = options[:spec] || options[:spec_fallback]
abort "No input format (spec) specified and none could be inferred." unless spec
abort "Invalid input format (spec): #{spec}. Use '-L' to get a list of available specs." unless Athena.valid_input_format?(spec)

format = options[:format] || options[:format_fallback]
abort "No output format specified and none could be inferred." unless format
abort "Invalid output format: #{format}. Use '-l' to get a list of available formats." unless Athena.valid_output_format?(format)

yaml = YAML.load_file(options[:config])
if t = options[:target]
  target = t
  config = yaml[t.to_sym]
else
  [options[:target_fallback] || 'generic', ".#{spec}", ":#{format}"].inject([]) { |s, t|
    s << (s.last ? s.last + t : t)
  }.reverse.find { |t|
    target = t
    config = yaml[t.to_sym]
  }
end
abort "Config not found for target: #{target}." unless config

parser = Athena.parser(config, spec)

if Athena.deferred_output?(format)
  res = parser.parse(options[:input])

  res.map { |record|
    record.to(format)
  }.flatten.sort.uniq.each { |line|
    options[:output].puts line
  }
elsif Athena.raw_output?(format)
  res = Athena.with_format(format, options[:output]) { |_format|
    parser.parse(options[:input]) { |record|
      record.to(_format)
    }
  }
else
  res = Athena.with_format(format) { |_format|
    parser.parse(options[:input]) { |record|
      options[:output].puts record.to(_format)
    }
  }
end

Athena::Util.verbose(:count) { spit res.is_a?(Numeric) ? res : res.size }
